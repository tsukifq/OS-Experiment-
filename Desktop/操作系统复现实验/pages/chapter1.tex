\chapter{操作系统复现内容总览}

\section{实验环境的搭建}
实验内容：在 Windows 操作系统下安装虚拟机软件（如 Virtualbox，VMware等），然后在虚拟机上安装 Ubuntu 操作系统。安装 Bochs 模拟器 Bochs 模拟 X86硬件平台，并利用其自带 bochsdbg 调试器调试操作系统设计代码。\par
基本步骤：安装虚拟机；配置 Linux 环境；安装 Bochs 模拟器；安装 nasm、gcc、gnu 等工具；操作系统引导盘的制作；运行引导扇区。


\section{动手写一个最小的操作系统}
实验内容：通过编译一段最基本的 asm 代码来初次体验操作系统的设计以及了解 NASM 编译的使用方法、dd 命令写入磁盘的方法以及 Bochs 的使用方法。\par
基本步骤：NASM编译；dd 命令写入磁盘，软盘读写工具将文件写到空白软盘的第一个扇区；调用子程序显示字符串，并无限循环；bximage 命令创建一个空白映像文件，再使用dd 命令将.bin 文件写入；撰写bochsrc文件，配置 bochs 基本信息，使用.bin 文件从指定软盘启动；启动后进行调试。


\section{实现保护模式}
实验内容：认识保护模式，实现从实模式到保护模式的转换，GDT 描述符；实现实模式大于 1MB 内存的寻址能力，并接着上一次实验，从保护模式返回到实模式，重新设置各个段寄存器的值；LDT 描述符；学会使用挂载指令和运行程序。\par
实验步骤：借助 DOS 扩展程序范围，安装FreeDos，并将两个软盘映像都写进bochs配置文件；学习数据结构 GDT及其描述符；学习数据结构 LDT，关注其区别于GDT的局部特性；把.asm 文件编译成.com 文件，使用挂载指令将该文件复制到软盘映像文件里；了解保护模式如何获取大于 1MB 寻址能力；认识实模式和保护模式以及互相跳转的方式。

\section{切换到保护模式}
实验内容：引导扇区突破 512 个字节的限制，将工作分给 loader；加载 loader 进入内存并运行；将控制权交给 loader。\par
基本步骤：突破 512 字节的限制：交给 loader 来完成；认识 FAT12，遍历根目录区所有的扇区，将每一个扇区加载入内存，从中寻找 Loader.bin；使用 jmp 指令跳到内存中 loader.bin 的开始处；向 loader交出控制权。

\section{内核雏形}
实验内容：在 Linux 下用汇编写 Hello, World！；进一步，汇编和 C 同时使用；从 loader 到 kernel 内核，把 kernel 内核加载到内存；将控制权交给 kernel 内核；跳入保护模式,并显示内存的使用情况。\par
基本步骤：linux 汇编下的 hello world：helloworld 编译成 elf 格式；./hello 运行；汇编和 C 同时使用：通过global 导出，extern 声明；./hello 运行；从 loader 到内核：用 loader 把 kernel 加载到内存；进入保护模式；控制权交给内核：把 Kernel.bin 加载到内存。

\section{进程及进程调度}
实验内容：进程切换；丰富中断处理程序，比如让时钟中断处理可以不停地发生而不是只发生一次，进程状态的保存与恢复，进程调度，解决中断重入问题。\par
基本步骤：学习最简单的进程：进程表、进程栈、内核栈；特权级变换；寄存器值的压栈和恢复；准备进程体；初始化相应描述符；准备进程表；完成特权级别的跳转；丰富中断处理：设置 EOI、现场的保护和恢复、中断重入；多进程处理：读取不同的任务地址入口、堆栈栈顶和进程名；进程切换；系统调用；进程调度。

\section{输入/输出系统}
实验内容：实现简单的 I/O，从键盘输入字符的中断开始；获取并打印扫描码；创建对应打印扫描码解析数组，打印对应字符。\par
基本步骤：添加中断指令，多次输入；打印 make code 和 break mode；建立键盘输入缓冲区分析字符；处理 shift、alt 和 ctrl相关组合键；

\section{操作系统进阶}
实验内容：自定义一个系统调用，能够统计一个进程在执行的过程中被调度的次数。编写一个简单的用户程序，调用该自定义的系统调用，从而将进程及其调度的次数输出在屏幕上。并在实现了三个进程的优先级调度的基础上，将三个进程的循环次数从无限循环修改为有限次数，当三个进程执行完成时，计算三个进程在优先级调度算法下的周转时间、等待时间以及该系统的平均周转时间、平均等待时间和吞吐量。也可以添加新的进程，然后计算该系统的平均周转时间、平均等待时间和吞吐量。\par
基本步骤：从系统调用开始：定义系统调用函数体；定义函数声明；添加 sys$\_$call$\_$table 成员；增加NR$\_$SYS$\_$CALL的值；返回输出用户进程的函数调用次数；初始化进程表同时定义进程优先级和调用次数；设计进程调度算法；返回输出系统的平均周转时间、平均等待时间和吞吐量、
